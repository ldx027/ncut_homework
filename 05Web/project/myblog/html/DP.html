<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/paging.css">
    <title>DP</title>
</head>

<body>
    <div class="topbar">
        <div class="container1">
            <a href="index.html">
            <div>OI-Wiki</div>
            </a>
            <ul class="top-nav">
                <li>
                    <span>比赛相关</span>
                    <div class="sec-nav">
                        <ul>
                            <li><a href="比赛相关简介.html">比赛相关简介</a></li>
                            <li><a href="赛事.html">赛事</a></li>
                            <li><a href="题型.html">题型</a></li>
                        </ul>
                    </div>
                </li>
                <li>
                    <span>比赛相关</span>
                    <div class="sec-nav">
                        <ul>
                            <li><a href="搜索算法简介.html">搜索部分简介</a></li>
                            <li><a href="搜索算法.html">搜索算法</a></li>
                            <li><a href="搜索算法优化.html">优化</a></li>
                        </ul>
                    </div>
                </li>
                </li>
                <li>
                    <span>动态规划</span>
                    <div class="sec-nav">
                        <ul>
                            <li><a href="动态规划简介.html">简介</a></li>
                            <li><a href="动态规划基础.html">动态规划基础</a></li>
                            <li><a href="记忆化搜索.html">记忆化搜索</a></li>
                            <li><a href="DP.html">DP</a></li>
                            <li><a href="DP优化.html">DP优化</a></li>
                        </ul>
                    </div>
                </li>
                </li>
                <li>
                    <span>数据结构</span>
                    <div class="sec-nav">
                        <ul>
                            <li><a href="数据结构简介.html">简介</a></li>
                            <li><a href="基本数据结构.html">基础数据结构</a></li>
                            <li><a href="进阶数据结构.html">进阶数据结构</a></li>
                            <li><a href="树形数据结构.html">树形数据结构</a></li>
                        </ul>
                    </div>
                </li>
                </li>
                <li>
                    <span>字符串</span>
                    <div class="sec-nav">
                        <ul>
                            <li><a href="字符串部分简介.html">字符串部分简介</a></li>
                            <li><a href="字符串哈希.html">字符串哈希</a></li>
                            <li><a href="字典树.html">字典树</a></li>
                            <ul>
                    </div>
                </li>
                </li>
                <li>
                    <span>图论</span>
                    <div class="sec-nav">
                        <ul>
                            <li><a href="图论相关概念.html">图论相关概念</a></li>
                            <li><a href="图的存储.html">图的存储</a></li>
                            <li><a href="树上问题.html">树上问题</a></li>
                        </ul>
                    </div>
                </li>
                </li>
            </ul>
        </div>
    </div>
    <div class="container2">
        <h1>
            DP
        </h1>
        <h2 id="anchor1">

            背包 DP
        </h2>
        <h3>

            引入
        </h3>
        <p>

            在具体讲何为「背包 dp」前，先来看如下的例题：
        </p>
        <p>

            题意概要：有 n 个物品和一个容量为 W 的背包，每个物品有重量 w_{i} 和价值 v_{i} 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。
        </p>
        <p>

            在上述例题中，由于每个物体只有两种可能的状态（取与不取），对应二进制中的 0 和 1，这类问题便被称为「0-1 背包问题」。
        </p>
        <h3>

            0-1 背包
        </h3>
        <h4>

            解释
        </h4>
        <p>

            例题中已知条件有第 i 个物品的重量 w_{i}，价值 v_{i}，以及背包的总容量 W。
        </p>
        <p>

            设 DP 状态 f_{i,j} 为在只能放前 i 个物品的情况下，容量为 j 的背包所能达到的最大总价值。
        </p>
        <p>

            考虑转移。假设当前已经处理好了前 i-1 个物品的所有状态，那么对于第 i 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为
            f_{i-1,j}；当其放入背包时，背包的剩余容量会减小 w_{i}，背包中物品的总价值会增大 v_{i}，故这种情况的最大价值为 f_{i-1,j-w_{i}}+v_{i}。
        </p>
        <p>

            由此可以得出状态转移方程：
        </p>
        <code>

f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})
        </code>
        <p>

            这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。
        </p>
        <p>

            由于对 f_i 有影响的只有 f_{i-1}，可以去掉第一维，直接用 f_{i} 来表示处理到当前物品时背包容量为 i 的最大价值，得出以下方程：
        </p>
        <h3>

            完全背包
        </h3>
        <h4>

            解释
        </h4>
        <p>

            完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。
        </p>
        <p>

            我们可以借鉴 0-1 背包的思路，进行状态定义：设 f_{i,j} 为只能选前 i 个物品时，容量为 j 的背包可以达到的最大价值。
        </p>
        <p>

            需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。
        </p>
        <h4>

            过程
        </h4>
        <p>

            可以考虑一个朴素的做法：对于第 i 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 O(n^3) 的。
        </p>

        <h2 id="anchor2">

            区间 DP
        </h2>
        <h3>

            定义
        </h3>
        <p>

            区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。
        </p>
        <h2 id="anchor3">

            状压 DP
        </h2>
        <h3>

            定义
        </h3>
        <p>

            状压 DP 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。
        </p>
        <h2 id="anchor4">

            数位 DP
        </h2>
        <p>

            数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。
        </p>
        <p>

            数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：
        </p>
        <p>

            要求统计满足一定条件的数的数量（即，最终目的为计数）；
        </p>
        <p>

            这些条件经过转化后可以使用「数位」的思想去理解和判断；
        </p>
        <p>

            输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；
        </p>
        <p>

            上界很大（比如 10^{18}），暴力枚举验证会超时。
        </p>
        <p>


            数位 DP 的基本原理：
        </p>
        <p>

            考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999
            的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP
            的方式进行状态转移。
        </p>
        <p>

            数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即 \mathit{ans}_{[l, r]} = \mathit{ans}_{[0, r]}-\mathit{ans}_{[0, l
            - 1]}）
        </p>
        <p>

            那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。
        </p>
        <div class="foot-nav">
            <div>
                <a href="DP优化.html" class="next">下一篇</a>
                <a href="记忆化搜索.html" class="prev">上一篇</a>
            </div>
        </div>
    </div>
</body>

</html>